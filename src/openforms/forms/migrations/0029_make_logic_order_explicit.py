# Generated by Django 3.2.13 on 2022-06-23 11:02

from collections import defaultdict
from itertools import chain
from typing import Set

from django.db import migrations

from openforms.formio.utils import iter_components
from openforms.utils.json_logic import JsonLogicTest


def find_component_keys(test: JsonLogicTest, candidates: list) -> Set[str]:
    keys_used = set()

    for value in test.values:
        if isinstance(value, JsonLogicTest) and value.operator == "var":
            candidate = value.values[0]
            if candidate in candidates:
                keys_used.add(candidate)
        elif isinstance(value, JsonLogicTest) and value.operator == "date":
            keys_used |= find_component_keys(value, candidates=candidates)

        elif isinstance(value, JsonLogicTest):
            keys_used |= find_component_keys(value, candidates=candidates)

    return keys_used


def make_logic_order_explicit(apps, schema_editor):
    """
    Set an explicit order value for logic rules, per form.

    Since there was no explicit ordering beforehand, we apply the following logic:

    1. Simple rules: introspect the trigger and check which key it is for
        1. Look up the key in the form components
        2. Derive which form step the key belongs to
        3. Order based on form step order
        4. Within a form step, order on component hierarchy, depth first (i.e. we fetch
           child components before stepping to siblings.
        5. If still ambiguous, order by PK
    2. Simple rules that failed introspection
    3. Advanced rules: order by PK
    """
    Form = apps.get_model("forms", "Form")
    FormLogic = apps.get_model("forms", "FormLogic")

    objects = []
    for form in Form.objects.prefetch_related("formlogic_set"):
        logic_without_vars = []
        logic_with_vars = []

        # track which key belongs to which form step
        key_to_step_map = {}
        # list of keys in depth-first order for every form step
        depth_first_ordered_keys = defaultdict(list)

        for form_step in form.formstep_set.select_related("form_definition"):
            _keys = []

            for component in iter_components(
                form_step.form_definition.configuration, recursive=True
            ):
                if not (key := component.get("key")):
                    continue
                _keys.append(key)
                key_to_step_map[key] = form_step

            depth_first_ordered_keys[form_step] = _keys

        # introspect the logic
        for form_logic in form.formlogic_set.all():
            logic_test = JsonLogicTest.from_expression(form_logic.json_logic_trigger)
            component_keys = find_component_keys(
                logic_test, candidates=list(key_to_step_map)
            )

            if not component_keys:
                logic_without_vars.append(form_logic)
                continue

            steps_used = sorted(
                {key_to_step_map[key] for key in component_keys},
                key=lambda step: step.order,
            )
            logic_with_vars.append((steps_used, component_keys, form_logic))

        def logic_with_vars_sort_key(logic_tuple):
            steps_used, component_keys, form_logic = logic_tuple
            key_indices_by_step = defaultdict(set)

            for key in component_keys:
                step = key_to_step_map[key]
                key_indices_by_step[step].add(depth_first_ordered_keys[step].index(key))

            steps_and_keys = []
            for step in steps_used:
                key_indices = sorted(key_indices_by_step[step])
                steps_and_keys.append((step.order, tuple(key_indices)))

            return (tuple(steps_and_keys), form_logic.id)

        # process the ordering of simple logics
        sorted_logic_with_vars = [
            form_logic
            for (_, _, form_logic) in sorted(
                logic_with_vars, key=logic_with_vars_sort_key
            )
        ]
        # process ambiguous_simple_logics
        sorted_logic_without_vars = sorted(
            logic_without_vars, key=lambda logic: logic.id
        )

        for order, form_logic in enumerate(
            chain(
                sorted_logic_without_vars,
                sorted_logic_with_vars,
            )
        ):
            # only update what needs to be changed
            if order == form_logic.order:
                continue
            form_logic.order = order
            objects.append(form_logic)

    FormLogic.objects.bulk_update(objects, fields=["order"])


class Migration(migrations.Migration):

    dependencies = [
        ("forms", "0028_auto_20220623_1257"),
    ]

    operations = [
        migrations.RunPython(make_logic_order_explicit, migrations.RunPython.noop),
    ]
